# -*- coding: utf-8 -*-
"""CP468 Term Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j_dzBtsMkTSEoMIanRG7GRYs0vN5Ymt7
"""

from datetime import datetime
import random


class Min_Conflict(object):

    # Constructor for the Min_Conflict class. Contains an n int array to represent the chessboard
    def __init__(self, size_of_board):
        # self.queens_position: n size int array, each number represents a position of a queen.
        # For example,[1,2,3], 1 represents the first queen locates at first column, second row( row starts with 0)
        self.queens_position = []
        # self.candidates_queens: contains all possible queens, which can be moved in next steps
        self.candidates_queens = []
        # It will ask user to decide the size of chessboard
        self.size_of_board = size_of_board

    # This function to check the number of conflicts given a queen
    # This function will return the number the of conflicts of a given queen
    def check_conflicts_number(self, row, col):
        conflict_counter = 0
        for val in range(len(self.queens_position)):
            if val != col:
                next_queen_row = self.queens_position[val]
                # If there is other queen in the same row or diagonal, conflicts should increase
                if next_queen_row == row or abs(next_queen_row - row) == abs(val - col):
                    conflict_counter += 1
        return conflict_counter

    # This function is used to initialize a chessboard with n queens
    def Initialize_chessboard(self):
        for col in range(self.size_of_board):
            # This is used to determine the best placement. maxed out at n
            min_conflict = self.size_of_board
            # Create a candidates array
            self.candidates_queens = []
            # Finds the rows with the least number of conflicts and adds them to the candidates_queen array
            self.queens_position.append(0)
            for row in range(len(self.queens_position)):
                
                num_of_conflicts = self.check_conflicts_number(self.queens_position[row], col)
                if num_of_conflicts == min_conflict:
                    self.candidates_queens.append(row)
                elif num_of_conflicts < min_conflict:
                    self.candidates_queens = []
                    self.candidates_queens.append(row)
                    min_conflict = num_of_conflicts
                print(self.queens_position)
            # Selects a random row from the suitable candidates array; then, change the position of the old queens' position based on that
            self.queens_position[col] = random.choice(self.candidates_queens)

    # This function is used to move the queen to the next position based on the random selected row from the candidates_queens array
    def move_queen_to(self, queen_col):
        # Create candidate array
        self.candidates_queens = []
        min_conflict = self.size_of_board
        # Finds the rows with the least number of conflicts and adds them to the candidates_queen array
        for val in range(len(self.queens_position)):
            conflict_num = self.check_conflicts_number(val, queen_col)
            # Check whether the next move can reduce the overall conflicts number
            if conflict_num == min_conflict:
                self.candidates_queens.append(val)
            else:
                if conflict_num < min_conflict:
                    self.candidates_queens = []
                    min_conflict = conflict_num
                    self.candidates_queens.append(val)
            # If there are candidates in the candidates_queens, continue to move the queen, otherwise, the solution is found
            self.queens_position[queen_col] = random.choice(self.candidates_queens)
        return self.queens_position[queen_col]

    # This function is used to solve the board and it will print the number of turns it took to solve
    def Solve(self):
        number_of_moves = 0
        while True:
            num_of_conflicts = 0
            self.candidates_queens = []

            # Checks for the total conflicts of the given chessboard
            for val in range(len(self.queens_position)):
                num_of_conflicts += self.check_conflicts_number(self.queens_position[val], val)
            # If there are no conflicts on the board return the moves, which refers to the problem has been solved
            if num_of_conflicts == 0:
                return number_of_moves

            # Choose a random queen to move and increase the move counter
            random_queen = random.randint(0, len(self.queens_position) - 1)
            rand = self.move_queen_to(random_queen)
            number_of_moves += 1
            print("Step {}:".format(number_of_moves))
            print("Candidate rows: ", self.candidates_queens, end=",")
            print(" random selection:", rand)
            self.print_chessboard()

    def print_chessboard(self):
        row_print = ''
        for i in range(len(self.queens_position)):
            for x in range(len(self.queens_position)):
                if self.queens_position[x] == i:
                    # "Q" represents queen in the current position
                    row_print += "Q "
                else:
                    # Nothing in the current position
                    row_print += "X "
            row_print += "\n"
        print (row_print)


def main():
    # Create a random machine
    random.seed(datetime.now())

    # # test 8-queen 100 times
    # total_times=0
    # total_moves=0
    # for j in range(0,10):
    #     for i in range(0,10):
    #         n_queen_game = Min_Conflict(8)
    #         n_queen_game.Initialize_chessboard()
    #         num_of_moves = n_queen_game.Quick_Solve()
    #         total_times+=1
    #         total_moves+=num_of_moves
    #         print("{} : {} steps to solve 8-queen puzzle".format(i+1,num_of_moves))
    # avg = total_moves/total_times
    # print("It took {} steps in average to solve the 8-queen puzzle".format(avg))

    # Ask user for the input, if input invalid (2 or 3), keep asking, there is no solution for 2 or 3 queen chessboard
    size_of_board = int(input("What is the size of the puzzle? (At least 4 queens): "))
    while size_of_board in [2, 3]:
        print("No solution for 2-queen game or 3-queen game! Please initialize at least 4 queens or you are allowed to try 1.")
        print()
        size_of_board = int(input("What is the size of the puzzle? (At least 4 queens)"))
        
    # Initialize the Min_Conflict object
    n_queen_game = Min_Conflict(size_of_board)

    # Initialize the n-queen board with random assignment of the queens, all the position of queens in the initial chessboard are randomly chosen
    n_queen_game.Initialize_chessboard()
    print("\nIninitial board:")
    n_queen_game.print_chessboard()

    # Call the Solve function and solve the chessboard
    num_of_moves = n_queen_game.Solve()
    
    # Print the final solution
    print("Final solution:")
    print("Candidate rows: ", n_queen_game.candidates_queens, ", no more candidates, we have finished the game!")
    n_queen_game.print_chessboard()
    
    # Print how many steps are used so far to solve the problem
    print("The Min-Conflict algorithm took", num_of_moves, "steps to solve the {}-queen puzzle.".format(size_of_board))


if __name__ == "__main__":
    main()
